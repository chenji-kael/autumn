// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pspb.proto

package pspb

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type RawBlockType int32

const (
	RawBlockType_data RawBlockType = 0
	RawBlockType_meta RawBlockType = 1
)

var RawBlockType_name = map[int32]string{
	0: "data",
	1: "meta",
}

var RawBlockType_value = map[string]int32{
	"data": 0,
	"meta": 1,
}

func (x RawBlockType) String() string {
	return proto.EnumName(RawBlockType_name, int32(x))
}

func (RawBlockType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3e3c719c85d382a4, []int{0}
}

type MixedLog struct {
	Offsets []uint32 `protobuf:"varint,1,rep,packed,name=offsets,proto3" json:"offsets,omitempty"`
}

func (m *MixedLog) Reset()         { *m = MixedLog{} }
func (m *MixedLog) String() string { return proto.CompactTextString(m) }
func (*MixedLog) ProtoMessage()    {}
func (*MixedLog) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e3c719c85d382a4, []int{0}
}
func (m *MixedLog) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MixedLog) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MixedLog.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MixedLog) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MixedLog.Merge(m, src)
}
func (m *MixedLog) XXX_Size() int {
	return m.Size()
}
func (m *MixedLog) XXX_DiscardUnknown() {
	xxx_messageInfo_MixedLog.DiscardUnknown(m)
}

var xxx_messageInfo_MixedLog proto.InternalMessageInfo

func (m *MixedLog) GetOffsets() []uint32 {
	if m != nil {
		return m.Offsets
	}
	return nil
}

//
//PART_%d/range => [startKey, endKey]
//PART_%d/blobStreams => [id,...,id]
//PART_%d/logStream => id
//PART_%d/rowStream => id
//PART_%d/tables => [(extentID,offset),...,(extentID,offset)]
type Range struct {
	StartKey []byte `protobuf:"bytes,1,opt,name=startKey,proto3" json:"startKey,omitempty"`
	EndKey   []byte `protobuf:"bytes,2,opt,name=endKey,proto3" json:"endKey,omitempty"`
}

func (m *Range) Reset()         { *m = Range{} }
func (m *Range) String() string { return proto.CompactTextString(m) }
func (*Range) ProtoMessage()    {}
func (*Range) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e3c719c85d382a4, []int{1}
}
func (m *Range) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Range) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Range.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Range) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Range.Merge(m, src)
}
func (m *Range) XXX_Size() int {
	return m.Size()
}
func (m *Range) XXX_DiscardUnknown() {
	xxx_messageInfo_Range.DiscardUnknown(m)
}

var xxx_messageInfo_Range proto.InternalMessageInfo

func (m *Range) GetStartKey() []byte {
	if m != nil {
		return m.StartKey
	}
	return nil
}

func (m *Range) GetEndKey() []byte {
	if m != nil {
		return m.EndKey
	}
	return nil
}

type TableLocation struct {
	ExtentID uint64 `protobuf:"varint,1,opt,name=extentID,proto3" json:"extentID,omitempty"`
	Offset   uint32 `protobuf:"varint,2,opt,name=offset,proto3" json:"offset,omitempty"`
}

func (m *TableLocation) Reset()         { *m = TableLocation{} }
func (m *TableLocation) String() string { return proto.CompactTextString(m) }
func (*TableLocation) ProtoMessage()    {}
func (*TableLocation) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e3c719c85d382a4, []int{2}
}
func (m *TableLocation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableLocation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableLocation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableLocation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableLocation.Merge(m, src)
}
func (m *TableLocation) XXX_Size() int {
	return m.Size()
}
func (m *TableLocation) XXX_DiscardUnknown() {
	xxx_messageInfo_TableLocation.DiscardUnknown(m)
}

var xxx_messageInfo_TableLocation proto.InternalMessageInfo

func (m *TableLocation) GetExtentID() uint64 {
	if m != nil {
		return m.ExtentID
	}
	return 0
}

func (m *TableLocation) GetOffset() uint32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

type PartitionMeta struct {
	Range       *Range           `protobuf:"bytes,1,opt,name=range,proto3" json:"range,omitempty"`
	BlobStreams []uint64         `protobuf:"varint,2,rep,packed,name=blobStreams,proto3" json:"blobStreams,omitempty"`
	LogStream   uint64           `protobuf:"varint,3,opt,name=logStream,proto3" json:"logStream,omitempty"`
	RowStream   uint64           `protobuf:"varint,4,opt,name=rowStream,proto3" json:"rowStream,omitempty"`
	Tables      []*TableLocation `protobuf:"bytes,5,rep,name=tables,proto3" json:"tables,omitempty"`
}

func (m *PartitionMeta) Reset()         { *m = PartitionMeta{} }
func (m *PartitionMeta) String() string { return proto.CompactTextString(m) }
func (*PartitionMeta) ProtoMessage()    {}
func (*PartitionMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e3c719c85d382a4, []int{3}
}
func (m *PartitionMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PartitionMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PartitionMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PartitionMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PartitionMeta.Merge(m, src)
}
func (m *PartitionMeta) XXX_Size() int {
	return m.Size()
}
func (m *PartitionMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_PartitionMeta.DiscardUnknown(m)
}

var xxx_messageInfo_PartitionMeta proto.InternalMessageInfo

func (m *PartitionMeta) GetRange() *Range {
	if m != nil {
		return m.Range
	}
	return nil
}

func (m *PartitionMeta) GetBlobStreams() []uint64 {
	if m != nil {
		return m.BlobStreams
	}
	return nil
}

func (m *PartitionMeta) GetLogStream() uint64 {
	if m != nil {
		return m.LogStream
	}
	return 0
}

func (m *PartitionMeta) GetRowStream() uint64 {
	if m != nil {
		return m.RowStream
	}
	return 0
}

func (m *PartitionMeta) GetTables() []*TableLocation {
	if m != nil {
		return m.Tables
	}
	return nil
}

type MetaStreamData struct {
	LogStreamID  uint64 `protobuf:"varint,1,opt,name=logStreamID,proto3" json:"logStreamID,omitempty"`
	RawStreamID  uint64 `protobuf:"varint,2,opt,name=rawStreamID,proto3" json:"rawStreamID,omitempty"`
	BlobStreamID uint64 `protobuf:"varint,3,opt,name=blobStreamID,proto3" json:"blobStreamID,omitempty"`
}

func (m *MetaStreamData) Reset()         { *m = MetaStreamData{} }
func (m *MetaStreamData) String() string { return proto.CompactTextString(m) }
func (*MetaStreamData) ProtoMessage()    {}
func (*MetaStreamData) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e3c719c85d382a4, []int{4}
}
func (m *MetaStreamData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetaStreamData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MetaStreamData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MetaStreamData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetaStreamData.Merge(m, src)
}
func (m *MetaStreamData) XXX_Size() int {
	return m.Size()
}
func (m *MetaStreamData) XXX_DiscardUnknown() {
	xxx_messageInfo_MetaStreamData.DiscardUnknown(m)
}

var xxx_messageInfo_MetaStreamData proto.InternalMessageInfo

func (m *MetaStreamData) GetLogStreamID() uint64 {
	if m != nil {
		return m.LogStreamID
	}
	return 0
}

func (m *MetaStreamData) GetRawStreamID() uint64 {
	if m != nil {
		return m.RawStreamID
	}
	return 0
}

func (m *MetaStreamData) GetBlobStreamID() uint64 {
	if m != nil {
		return m.BlobStreamID
	}
	return 0
}

//BlockMeta will be marshaled into pb.Block.userdata
type RawBlockMeta struct {
	Type             RawBlockType `protobuf:"varint,1,opt,name=type,proto3,enum=pspb.RawBlockType" json:"type,omitempty"`
	CompressedSize   uint32       `protobuf:"varint,2,opt,name=CompressedSize,proto3" json:"CompressedSize,omitempty"`
	UnCompressedSize uint32       `protobuf:"varint,3,opt,name=UnCompressedSize,proto3" json:"UnCompressedSize,omitempty"`
	VpExtentID       uint64       `protobuf:"varint,4,opt,name=vpExtentID,proto3" json:"vpExtentID,omitempty"`
	VpOffset         uint32       `protobuf:"varint,5,opt,name=vpOffset,proto3" json:"vpOffset,omitempty"`
	SeqNum           uint64       `protobuf:"varint,6,opt,name=seqNum,proto3" json:"seqNum,omitempty"`
}

func (m *RawBlockMeta) Reset()         { *m = RawBlockMeta{} }
func (m *RawBlockMeta) String() string { return proto.CompactTextString(m) }
func (*RawBlockMeta) ProtoMessage()    {}
func (*RawBlockMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e3c719c85d382a4, []int{5}
}
func (m *RawBlockMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RawBlockMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RawBlockMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RawBlockMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RawBlockMeta.Merge(m, src)
}
func (m *RawBlockMeta) XXX_Size() int {
	return m.Size()
}
func (m *RawBlockMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_RawBlockMeta.DiscardUnknown(m)
}

var xxx_messageInfo_RawBlockMeta proto.InternalMessageInfo

func (m *RawBlockMeta) GetType() RawBlockType {
	if m != nil {
		return m.Type
	}
	return RawBlockType_data
}

func (m *RawBlockMeta) GetCompressedSize() uint32 {
	if m != nil {
		return m.CompressedSize
	}
	return 0
}

func (m *RawBlockMeta) GetUnCompressedSize() uint32 {
	if m != nil {
		return m.UnCompressedSize
	}
	return 0
}

func (m *RawBlockMeta) GetVpExtentID() uint64 {
	if m != nil {
		return m.VpExtentID
	}
	return 0
}

func (m *RawBlockMeta) GetVpOffset() uint32 {
	if m != nil {
		return m.VpOffset
	}
	return 0
}

func (m *RawBlockMeta) GetSeqNum() uint64 {
	if m != nil {
		return m.SeqNum
	}
	return 0
}

type BlockOffset struct {
	Key      []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	ExtentID uint64 `protobuf:"varint,2,opt,name=extentID,proto3" json:"extentID,omitempty"`
	Offset   uint32 `protobuf:"varint,3,opt,name=offset,proto3" json:"offset,omitempty"`
}

func (m *BlockOffset) Reset()         { *m = BlockOffset{} }
func (m *BlockOffset) String() string { return proto.CompactTextString(m) }
func (*BlockOffset) ProtoMessage()    {}
func (*BlockOffset) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e3c719c85d382a4, []int{6}
}
func (m *BlockOffset) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockOffset) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockOffset.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockOffset) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockOffset.Merge(m, src)
}
func (m *BlockOffset) XXX_Size() int {
	return m.Size()
}
func (m *BlockOffset) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockOffset.DiscardUnknown(m)
}

var xxx_messageInfo_BlockOffset proto.InternalMessageInfo

func (m *BlockOffset) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *BlockOffset) GetExtentID() uint64 {
	if m != nil {
		return m.ExtentID
	}
	return 0
}

func (m *BlockOffset) GetOffset() uint32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

type TableIndex struct {
	Offsets       []*BlockOffset `protobuf:"bytes,1,rep,name=offsets,proto3" json:"offsets,omitempty"`
	BloomFilter   []byte         `protobuf:"bytes,2,opt,name=bloom_filter,json=bloomFilter,proto3" json:"bloom_filter,omitempty"`
	EstimatedSize uint64         `protobuf:"varint,3,opt,name=estimated_size,json=estimatedSize,proto3" json:"estimated_size,omitempty"`
	NumOfBlocks   uint32         `protobuf:"varint,4,opt,name=numOfBlocks,proto3" json:"numOfBlocks,omitempty"`
}

func (m *TableIndex) Reset()         { *m = TableIndex{} }
func (m *TableIndex) String() string { return proto.CompactTextString(m) }
func (*TableIndex) ProtoMessage()    {}
func (*TableIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e3c719c85d382a4, []int{7}
}
func (m *TableIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableIndex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableIndex.Merge(m, src)
}
func (m *TableIndex) XXX_Size() int {
	return m.Size()
}
func (m *TableIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_TableIndex.DiscardUnknown(m)
}

var xxx_messageInfo_TableIndex proto.InternalMessageInfo

func (m *TableIndex) GetOffsets() []*BlockOffset {
	if m != nil {
		return m.Offsets
	}
	return nil
}

func (m *TableIndex) GetBloomFilter() []byte {
	if m != nil {
		return m.BloomFilter
	}
	return nil
}

func (m *TableIndex) GetEstimatedSize() uint64 {
	if m != nil {
		return m.EstimatedSize
	}
	return 0
}

func (m *TableIndex) GetNumOfBlocks() uint32 {
	if m != nil {
		return m.NumOfBlocks
	}
	return 0
}

func init() {
	proto.RegisterEnum("pspb.RawBlockType", RawBlockType_name, RawBlockType_value)
	proto.RegisterType((*MixedLog)(nil), "pspb.MixedLog")
	proto.RegisterType((*Range)(nil), "pspb.Range")
	proto.RegisterType((*TableLocation)(nil), "pspb.TableLocation")
	proto.RegisterType((*PartitionMeta)(nil), "pspb.PartitionMeta")
	proto.RegisterType((*MetaStreamData)(nil), "pspb.MetaStreamData")
	proto.RegisterType((*RawBlockMeta)(nil), "pspb.RawBlockMeta")
	proto.RegisterType((*BlockOffset)(nil), "pspb.BlockOffset")
	proto.RegisterType((*TableIndex)(nil), "pspb.TableIndex")
}

func init() { proto.RegisterFile("pspb.proto", fileDescriptor_3e3c719c85d382a4) }

var fileDescriptor_3e3c719c85d382a4 = []byte{
	// 558 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x54, 0xc1, 0x6e, 0xd3, 0x4c,
	0x10, 0x8e, 0x63, 0x27, 0x7f, 0xff, 0x71, 0x1d, 0x85, 0x45, 0x42, 0x16, 0x42, 0x96, 0x6b, 0x41,
	0x15, 0xb5, 0x52, 0x0f, 0xe1, 0xc8, 0xad, 0x0d, 0x48, 0x11, 0x2d, 0x45, 0x9b, 0x72, 0xae, 0x36,
	0xf5, 0x26, 0xb2, 0x1a, 0x7b, 0x8d, 0x77, 0xdb, 0x24, 0x3c, 0x05, 0x2f, 0xc1, 0x63, 0x70, 0xe7,
	0xd8, 0x23, 0x27, 0x84, 0x92, 0x17, 0x41, 0x3b, 0xeb, 0x38, 0x4e, 0x11, 0xb7, 0xfd, 0xbe, 0xf9,
	0x3c, 0x3b, 0xf3, 0xcd, 0xac, 0x01, 0x72, 0x99, 0x8f, 0x4f, 0xf2, 0x42, 0x28, 0x41, 0x1c, 0x7d,
	0x8e, 0x5e, 0xc2, 0xde, 0x45, 0xb2, 0xe0, 0xf1, 0xb9, 0x98, 0x12, 0x1f, 0xfe, 0x13, 0x93, 0x89,
	0xe4, 0x4a, 0xfa, 0x56, 0x68, 0xf7, 0x3c, 0xba, 0x81, 0xd1, 0x1b, 0x68, 0x51, 0x96, 0x4d, 0x39,
	0x79, 0x0e, 0x7b, 0x52, 0xb1, 0x42, 0xbd, 0xe7, 0x4b, 0xdf, 0x0a, 0xad, 0xde, 0x3e, 0xad, 0x30,
	0x79, 0x06, 0x6d, 0x9e, 0xc5, 0x3a, 0xd2, 0xc4, 0x48, 0x89, 0xa2, 0x33, 0xf0, 0xae, 0xd8, 0x78,
	0xc6, 0xcf, 0xc5, 0x0d, 0x53, 0x89, 0xc8, 0x74, 0x12, 0xbe, 0x50, 0x3c, 0x53, 0xc3, 0x01, 0x26,
	0x71, 0x68, 0x85, 0x75, 0x12, 0x73, 0x29, 0x26, 0xf1, 0x68, 0x89, 0xa2, 0xef, 0x16, 0x78, 0x1f,
	0x59, 0xa1, 0x12, 0x9d, 0xe1, 0x82, 0x2b, 0x46, 0x0e, 0xa0, 0x55, 0xe8, 0x9a, 0x30, 0x85, 0xdb,
	0x77, 0x4f, 0xb0, 0x37, 0x2c, 0x93, 0x9a, 0x08, 0x09, 0xc1, 0x1d, 0xcf, 0xc4, 0x78, 0xa4, 0x0a,
	0xce, 0x52, 0xe9, 0x37, 0x43, 0xbb, 0xe7, 0xd0, 0x3a, 0x45, 0x5e, 0xc0, 0xff, 0x33, 0x31, 0x35,
	0xc8, 0xb7, 0xb1, 0x96, 0x2d, 0xa1, 0xa3, 0x85, 0x98, 0x97, 0x51, 0xc7, 0x44, 0x2b, 0x82, 0x1c,
	0x43, 0x5b, 0xe9, 0xbe, 0xa4, 0xdf, 0x0a, 0xed, 0x9e, 0xdb, 0x7f, 0x6a, 0x2a, 0xd8, 0xe9, 0x95,
	0x96, 0x92, 0x68, 0x01, 0x1d, 0x5d, 0xb5, 0xf9, 0x74, 0xc0, 0x14, 0xd3, 0xc5, 0x55, 0x37, 0x55,
	0x46, 0xd4, 0x29, 0xad, 0x28, 0xd8, 0xbc, 0x52, 0x34, 0x8d, 0xa2, 0x46, 0x91, 0x08, 0xf6, 0xb7,
	0xdd, 0x0c, 0x07, 0x65, 0x07, 0x3b, 0x5c, 0xf4, 0xcb, 0x82, 0x7d, 0xca, 0xe6, 0xa7, 0x33, 0x71,
	0x73, 0x8b, 0xc6, 0x1d, 0x82, 0xa3, 0x96, 0xb9, 0xf1, 0xad, 0xd3, 0x27, 0x1b, 0xdf, 0x8c, 0xe2,
	0x6a, 0x99, 0x73, 0x8a, 0x71, 0x72, 0x08, 0x9d, 0x33, 0x91, 0xe6, 0x05, 0x97, 0x92, 0xc7, 0xa3,
	0xe4, 0x0b, 0x2f, 0x47, 0xf2, 0x88, 0x25, 0x47, 0xd0, 0xfd, 0x94, 0x3d, 0x52, 0xda, 0xa8, 0xfc,
	0x8b, 0x27, 0x01, 0xc0, 0x7d, 0xfe, 0x76, 0x33, 0x7c, 0x63, 0x69, 0x8d, 0xd1, 0xab, 0x71, 0x9f,
	0x5f, 0x9a, 0x05, 0x68, 0x61, 0x8e, 0x0a, 0xeb, 0xd5, 0x90, 0xfc, 0xf3, 0x87, 0xbb, 0xd4, 0x6f,
	0xe3, 0x77, 0x25, 0x8a, 0x46, 0xe0, 0x62, 0xe9, 0xa5, 0xac, 0x0b, 0xf6, 0x6d, 0xb5, 0x9d, 0xfa,
	0xb8, 0xb3, 0x6f, 0xcd, 0x7f, 0xee, 0x9b, 0xbd, 0xb3, 0x6f, 0xdf, 0x2c, 0x00, 0x9c, 0xe4, 0x30,
	0x8b, 0xf9, 0x82, 0x1c, 0xef, 0x3e, 0x0d, 0xb7, 0xff, 0xc4, 0xd8, 0x56, 0xbb, 0xb8, 0x7a, 0x2d,
	0xe4, 0x00, 0xa7, 0x22, 0xd2, 0xeb, 0x49, 0x32, 0x53, 0xbc, 0x28, 0x9f, 0x83, 0x8b, 0xdc, 0x3b,
	0xa4, 0xc8, 0x2b, 0xe8, 0x70, 0xa9, 0x92, 0x94, 0x29, 0x1e, 0x5f, 0xcb, 0x8d, 0x63, 0x0e, 0xf5,
	0x2a, 0x16, 0xed, 0x0a, 0xc1, 0xcd, 0xee, 0xd2, 0xcb, 0x09, 0x5e, 0x23, 0xd1, 0x2f, 0x8f, 0xd6,
	0xa9, 0xa3, 0x68, 0x3b, 0x5c, 0x3d, 0x3a, 0xb2, 0x07, 0x4e, 0xcc, 0x14, 0xeb, 0x36, 0xf4, 0x29,
	0xe5, 0x8a, 0x75, 0xad, 0x53, 0xff, 0xc7, 0x2a, 0xb0, 0x1e, 0x56, 0x81, 0xf5, 0x7b, 0x15, 0x58,
	0x5f, 0xd7, 0x41, 0xe3, 0x61, 0x1d, 0x34, 0x7e, 0xae, 0x83, 0xc6, 0xb8, 0x8d, 0xbf, 0x82, 0xd7,
	0x7f, 0x02, 0x00, 0x00, 0xff, 0xff, 0x5a, 0x06, 0x05, 0x56, 0x18, 0x04, 0x00, 0x00,
}

func (m *MixedLog) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MixedLog) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MixedLog) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Offsets) > 0 {
		dAtA2 := make([]byte, len(m.Offsets)*10)
		var j1 int
		for _, num := range m.Offsets {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintPspb(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Range) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Range) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Range) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EndKey) > 0 {
		i -= len(m.EndKey)
		copy(dAtA[i:], m.EndKey)
		i = encodeVarintPspb(dAtA, i, uint64(len(m.EndKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.StartKey) > 0 {
		i -= len(m.StartKey)
		copy(dAtA[i:], m.StartKey)
		i = encodeVarintPspb(dAtA, i, uint64(len(m.StartKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TableLocation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableLocation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableLocation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Offset != 0 {
		i = encodeVarintPspb(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x10
	}
	if m.ExtentID != 0 {
		i = encodeVarintPspb(dAtA, i, uint64(m.ExtentID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PartitionMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PartitionMeta) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PartitionMeta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Tables) > 0 {
		for iNdEx := len(m.Tables) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tables[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPspb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.RowStream != 0 {
		i = encodeVarintPspb(dAtA, i, uint64(m.RowStream))
		i--
		dAtA[i] = 0x20
	}
	if m.LogStream != 0 {
		i = encodeVarintPspb(dAtA, i, uint64(m.LogStream))
		i--
		dAtA[i] = 0x18
	}
	if len(m.BlobStreams) > 0 {
		dAtA4 := make([]byte, len(m.BlobStreams)*10)
		var j3 int
		for _, num := range m.BlobStreams {
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintPspb(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0x12
	}
	if m.Range != nil {
		{
			size, err := m.Range.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPspb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MetaStreamData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetaStreamData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetaStreamData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BlobStreamID != 0 {
		i = encodeVarintPspb(dAtA, i, uint64(m.BlobStreamID))
		i--
		dAtA[i] = 0x18
	}
	if m.RawStreamID != 0 {
		i = encodeVarintPspb(dAtA, i, uint64(m.RawStreamID))
		i--
		dAtA[i] = 0x10
	}
	if m.LogStreamID != 0 {
		i = encodeVarintPspb(dAtA, i, uint64(m.LogStreamID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RawBlockMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawBlockMeta) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RawBlockMeta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SeqNum != 0 {
		i = encodeVarintPspb(dAtA, i, uint64(m.SeqNum))
		i--
		dAtA[i] = 0x30
	}
	if m.VpOffset != 0 {
		i = encodeVarintPspb(dAtA, i, uint64(m.VpOffset))
		i--
		dAtA[i] = 0x28
	}
	if m.VpExtentID != 0 {
		i = encodeVarintPspb(dAtA, i, uint64(m.VpExtentID))
		i--
		dAtA[i] = 0x20
	}
	if m.UnCompressedSize != 0 {
		i = encodeVarintPspb(dAtA, i, uint64(m.UnCompressedSize))
		i--
		dAtA[i] = 0x18
	}
	if m.CompressedSize != 0 {
		i = encodeVarintPspb(dAtA, i, uint64(m.CompressedSize))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintPspb(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BlockOffset) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockOffset) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockOffset) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Offset != 0 {
		i = encodeVarintPspb(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x18
	}
	if m.ExtentID != 0 {
		i = encodeVarintPspb(dAtA, i, uint64(m.ExtentID))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintPspb(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TableIndex) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NumOfBlocks != 0 {
		i = encodeVarintPspb(dAtA, i, uint64(m.NumOfBlocks))
		i--
		dAtA[i] = 0x20
	}
	if m.EstimatedSize != 0 {
		i = encodeVarintPspb(dAtA, i, uint64(m.EstimatedSize))
		i--
		dAtA[i] = 0x18
	}
	if len(m.BloomFilter) > 0 {
		i -= len(m.BloomFilter)
		copy(dAtA[i:], m.BloomFilter)
		i = encodeVarintPspb(dAtA, i, uint64(len(m.BloomFilter)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Offsets) > 0 {
		for iNdEx := len(m.Offsets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Offsets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPspb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintPspb(dAtA []byte, offset int, v uint64) int {
	offset -= sovPspb(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MixedLog) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Offsets) > 0 {
		l = 0
		for _, e := range m.Offsets {
			l += sovPspb(uint64(e))
		}
		n += 1 + sovPspb(uint64(l)) + l
	}
	return n
}

func (m *Range) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovPspb(uint64(l))
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovPspb(uint64(l))
	}
	return n
}

func (m *TableLocation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExtentID != 0 {
		n += 1 + sovPspb(uint64(m.ExtentID))
	}
	if m.Offset != 0 {
		n += 1 + sovPspb(uint64(m.Offset))
	}
	return n
}

func (m *PartitionMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Range != nil {
		l = m.Range.Size()
		n += 1 + l + sovPspb(uint64(l))
	}
	if len(m.BlobStreams) > 0 {
		l = 0
		for _, e := range m.BlobStreams {
			l += sovPspb(uint64(e))
		}
		n += 1 + sovPspb(uint64(l)) + l
	}
	if m.LogStream != 0 {
		n += 1 + sovPspb(uint64(m.LogStream))
	}
	if m.RowStream != 0 {
		n += 1 + sovPspb(uint64(m.RowStream))
	}
	if len(m.Tables) > 0 {
		for _, e := range m.Tables {
			l = e.Size()
			n += 1 + l + sovPspb(uint64(l))
		}
	}
	return n
}

func (m *MetaStreamData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LogStreamID != 0 {
		n += 1 + sovPspb(uint64(m.LogStreamID))
	}
	if m.RawStreamID != 0 {
		n += 1 + sovPspb(uint64(m.RawStreamID))
	}
	if m.BlobStreamID != 0 {
		n += 1 + sovPspb(uint64(m.BlobStreamID))
	}
	return n
}

func (m *RawBlockMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovPspb(uint64(m.Type))
	}
	if m.CompressedSize != 0 {
		n += 1 + sovPspb(uint64(m.CompressedSize))
	}
	if m.UnCompressedSize != 0 {
		n += 1 + sovPspb(uint64(m.UnCompressedSize))
	}
	if m.VpExtentID != 0 {
		n += 1 + sovPspb(uint64(m.VpExtentID))
	}
	if m.VpOffset != 0 {
		n += 1 + sovPspb(uint64(m.VpOffset))
	}
	if m.SeqNum != 0 {
		n += 1 + sovPspb(uint64(m.SeqNum))
	}
	return n
}

func (m *BlockOffset) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovPspb(uint64(l))
	}
	if m.ExtentID != 0 {
		n += 1 + sovPspb(uint64(m.ExtentID))
	}
	if m.Offset != 0 {
		n += 1 + sovPspb(uint64(m.Offset))
	}
	return n
}

func (m *TableIndex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Offsets) > 0 {
		for _, e := range m.Offsets {
			l = e.Size()
			n += 1 + l + sovPspb(uint64(l))
		}
	}
	l = len(m.BloomFilter)
	if l > 0 {
		n += 1 + l + sovPspb(uint64(l))
	}
	if m.EstimatedSize != 0 {
		n += 1 + sovPspb(uint64(m.EstimatedSize))
	}
	if m.NumOfBlocks != 0 {
		n += 1 + sovPspb(uint64(m.NumOfBlocks))
	}
	return n
}

func sovPspb(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPspb(x uint64) (n int) {
	return sovPspb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MixedLog) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MixedLog: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MixedLog: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPspb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Offsets = append(m.Offsets, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPspb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPspb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPspb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Offsets) == 0 {
					m.Offsets = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPspb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Offsets = append(m.Offsets, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Offsets", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPspb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Range) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Range: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Range: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPspb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPspb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPspb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPspb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPspb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableLocation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableLocation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableLocation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtentID", wireType)
			}
			m.ExtentID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExtentID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPspb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PartitionMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PartitionMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PartitionMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPspb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPspb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Range == nil {
				m.Range = &Range{}
			}
			if err := m.Range.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPspb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.BlobStreams = append(m.BlobStreams, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPspb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPspb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPspb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.BlobStreams) == 0 {
					m.BlobStreams = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPspb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.BlobStreams = append(m.BlobStreams, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BlobStreams", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogStream", wireType)
			}
			m.LogStream = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogStream |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowStream", wireType)
			}
			m.RowStream = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RowStream |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPspb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPspb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tables = append(m.Tables, &TableLocation{})
			if err := m.Tables[len(m.Tables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPspb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetaStreamData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetaStreamData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetaStreamData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogStreamID", wireType)
			}
			m.LogStreamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogStreamID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawStreamID", wireType)
			}
			m.RawStreamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RawStreamID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlobStreamID", wireType)
			}
			m.BlobStreamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlobStreamID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPspb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawBlockMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawBlockMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawBlockMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= RawBlockType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompressedSize", wireType)
			}
			m.CompressedSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompressedSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnCompressedSize", wireType)
			}
			m.UnCompressedSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnCompressedSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpExtentID", wireType)
			}
			m.VpExtentID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VpExtentID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpOffset", wireType)
			}
			m.VpOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VpOffset |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqNum", wireType)
			}
			m.SeqNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqNum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPspb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockOffset) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockOffset: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockOffset: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPspb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPspb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtentID", wireType)
			}
			m.ExtentID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExtentID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPspb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offsets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPspb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPspb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Offsets = append(m.Offsets, &BlockOffset{})
			if err := m.Offsets[len(m.Offsets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BloomFilter", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPspb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPspb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BloomFilter = append(m.BloomFilter[:0], dAtA[iNdEx:postIndex]...)
			if m.BloomFilter == nil {
				m.BloomFilter = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EstimatedSize", wireType)
			}
			m.EstimatedSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EstimatedSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumOfBlocks", wireType)
			}
			m.NumOfBlocks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumOfBlocks |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPspb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPspb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPspb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPspb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPspb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPspb
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPspb
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPspb
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPspb        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPspb          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPspb = fmt.Errorf("proto: unexpected end of group")
)
